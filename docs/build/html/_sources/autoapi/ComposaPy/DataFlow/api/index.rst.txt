:py:mod:`ComposaPy.DataFlow.api`
================================

.. py:module:: ComposaPy.DataFlow.api


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   ComposaPy.DataFlow.api.DataFlow




.. py:class:: DataFlow(session: ComposaPy.session.Session)

   Bases: :py:obj:`ComposaPy.mixins.PandasMixin`, :py:obj:`ComposaPy.api.ComposableApi`

   A wrapper class for DataFlow operations.

   .. py:attribute:: _external_input_names
      :annotation: = ['External String Input', 'External Line Input', 'External Private Input', 'External Int Input',...

      

   .. py:attribute:: _application_contract
      

      

   .. py:method:: application_contract(self) -> CompAnalytics.Contracts.Application
      :property:


   .. py:method:: app_service(self) -> CompAnalytics.IServices.IApplicationService
      :property:


   .. py:method:: create(self, json: str = None, file_name: str = None) -> ComposaPy.DataFlow.models.DataFlowObject


   .. py:method:: save(self) -> Optional[CompAnalytics.Contracts.Application]


   .. py:method:: run_status(self, run_id: int)

      Checks status of a run.

      Parameters
      (int) run_id: id of the run

      Return
      (int) run_id: associated run id


   .. py:method:: wait_for_run_execution(self, run_id: int) -> dict[str, int]

      Waits until run has finished.

      Parameters
      (int) run_id: id of the run

      Return
      (dict[str, int]) execution_status: status of the execution


   .. py:method:: import_app_from_json(self, json: str) -> int

      import and save app from a json string of an app.

      Parameters
      (string) json: json string of app.

      Return
      (int) app_id: the id of the app.


   .. py:method:: run(self, app_id: int, external_inputs: dict[str, any] = None) -> Optional[ComposaPy.DataFlow.models.RunSet]

      Runs a dataflow from the app id.

      Parameters
      (int) id: id of the dataflow
      (dict[str,any]) external_inputs: any external modules (external int, table,
      file, etc) that require outside input to run can be added using a dictionary
      with the module input's name and corresponding value

      Return
      (int) run_id: associated run id


   .. py:method:: _overwrite_module_inputs(self, external_inputs: dict[str, any], module: CompAnalytics.Contracts.Module) -> None


   .. py:method:: _update_module_valueobj(self, external_inputs: dict[str, any], module: CompAnalytics.Contracts.Module, module_input) -> None


   .. py:method:: get_run_info(self, id: int) -> None



